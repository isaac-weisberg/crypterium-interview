В целом развернутый ответ, есть действительно дельные замечания. Дам экстенсивный ответ по тексту ниже. 

```
> Здравствуйте Екатерина,

> Я использовал дополнительное время для того чтобы проанализировать MVVM стек в предоставленном куске кода и я набрал журнал на мой взгляд достойных внимания замечаний.

Георгий в процессе формулирования своего запроса откровенно указывал что его интересуют флактруации в дизайне состояния вьюмодели - для себя я действительно нащупал проблемный участок который является большим контрибьтором в сложность системы. Я бы хотел указать на строку 365, именно в этот момент ко мне пришло осознание что де-факто вьюха тут не одна, а их тут две. Виджет инпута стринга поиска по списку контактов является достаточно независимым юнитом чтобы не иметь никакой привязки к виджету отображения списка контактов. И если на уровне вьюхи, единственным индикатором того что система спроектирована неоптимально является только лишь доступ их parent'а к экстенсивной конфигурации всех этих вьюх, то на уровне вьюмодели наблюдается куда более печальная картина: одна вьюмодель отвечает за: 
1. Работу со слоем моделей с целью получения и подготовки к презентации списка аккаунтов
2. Работу с бизнеслогикой виджета фильтрации, форматирования его инпута и применения значения из этого инпута к датасету.
Прямым доказательством этого утверждения является `ContactSelectorViewModel.updateSearch`, строка 107. Для обеспечения хорошей архитектуры, логику работы с инпутом и его форматированием нужно отпилить от большой вьюмодели в отдельную маленькую. Также, вся логика взаимодействий со слоем моделей с целью получения контактов тоже может быть унесена в отдельную вьюмодель. Текущей же вьюмодели в таком случае останется композировать результаты деятельности двух вьюмоделей - и от этого бизнес логика станет более чистой и атомарной. 
```

Да - эта проблема определена верно, это излишняя отвественность одной ViewModel. Что можно улучшить по ответу: решение с отпиливанием куска логики - наверное самое очевидное, но очевидно выходящий из предложенного решения вопрос - каким образом новые вьюмодели будут взаимодействовать - остался не решенным.

```
Отдельная инфраструктурная проблема которую я заметил связана со строкой 219, это на одном из методов вьюмодели. Там, в сигнатуре референсится модель задефайненная на вьюхе которая зависит от этой же самой вьюмодели, PhoneSelectorTableView.ViewProperties. С точки зрения архитектуры презентационного слоя, направление зависимостей абстракций у нас всегда должно быть однонаправленным. Это значит что абстракции более верхнеуровневые должны зависеть от абстракций более низкоуровневых. Осведомленность в слоях презентационного слоя должна быть от наименее переиспользуемых компонентов к наиболее переиспользуемым. В случае если бизнес скажет мне сделать вьюху, которая выглядит координально по-другому, но бизнес логика которой 1 в 1 соответствует представленной вьюмодели, на моих руках окажется очевидный кейс tight coupling'а. Вьюмодель прекрасно знает о том какую вьюху она ждет, и использует сигнатуры оттуда. Эта кросс-зависимость абстракций - строгое архитектурное нарушение.
```

Это очень спорное суждение - структура PhoneSelectorTableView.ViewProperties сама по себе ничего не расскрывает о PhoneSelectorTableView и не предоставляет прямой зависимости между View и ViewModel. Также могу сказать, на практике переиспользование ViewModel происходит редко. 

```
Также я обнаружил несколько использований протокола вьюмодели против ожидаемого мной одного - это была строка 300. В коде не представленно мест использования этой декларации (SelectedContactViewModel),но из чтения содержания у меня возникло впечатление что это урезанная версия той-же самой ContactSelectorViewModel которая отвечает на тот же интерфейс, но:
1. не включает в себя логику работы со многими контактами
2. не поддерживает фильрацию
3. стабильно выдает всего одну заданную модель
Я вижу прямую опасность в том что кто-то может быть заитересован в том чтобы переиспользовать вьюху, но при этом закинуть туда вьюмодель которая своей логикой сделает все так будто это detail-отображение одно контакта, а не список контактов. Это фатально неверный способ переиспользования вьюхи, и основным убийцей такого подхода является излишняя сложность вьюхи которую пытается переиспользовать автор. Верным вариантом было бы содержимое cell'а который способен отобразить модель контакт вынести в отдельную модулярную вьюху неосведомленную о своем parent'е и его вьюмодели. Ввиду этих измений, экран detail-представления модели контакта просто-бы имел в себе эту вьюху отображения контакта и там бы не было лишней бизнес-логики, сложной view model, и навигация вся была бы релеванта именно тем местам использованиям где оно появляется. Разумеется, cell на table view также в случае необходимости отображения подобной модели контакта использовал бы внутри себя эту же вьюху.
```

На мой взгляд из названия понятно - что модель необходима для отображения выбранного контакта. 

```
Касательно больших значимых замечаний по поводу архитектуры презентационного слоя, у меня всё.
- Строки 2 и 3 - дублированное состояние, есть возможность для инконсистенции. Фиксится тем чтобы сторить только индекс.
```

\+ 

```
- `ContactSelectorViewModel.allContacts`, строка 5 - опциональность добавляет еще одно возможное значение в общее поле значений. Есть ли разница между empty array и nil с точки зрения бизнеслогики, если нет - выпилить опциональность, если есть - подумать о том, что может быть часть полей вообще не должны существовать до какой-то точки жизненного цикла вьюмодели (до успешного запроса доступа), и решить эту state-machine с помощью энумератора с ассоциированными значениями?
```
судя по коду действительно опциональность излишне
```
- `PhoneSelectorTableView.ViewProperties.onTextChanged`, строка 339. У этого MVVM стека есть канал регулярных апдейтов, те самые view properties, которые постоянно меняются. Тем временем, onTextChanged остается неизменным - раз так, то стоит его инициализировать один раз при инъекции viewmodel. Это касается и  updateState.
```

\+ 
```
- Кейс .notFound у PhoneSelectorTableView.Section требует полноценной модели контакта, но учитывая что вьюмодель собирает его всегда одинаково и все что можно заполняет nil'ом / false'ом, есть ряд подозрений что под капотом ячейка модель не использует и модель требуется просто для того чтобы интерфейс был похож или что-то
```
Вроде из кода понятно, что ячейки не используют собственные ViewModel. И тут тоже вопрос насколько это эффективный подход в этом случае? И как определить где для ячейки нужна собственная ViewModel, а где можно обойтись без нее? 
```
- `ContactSelectorViewModel.afterInit`, строка 50, состояние игнорируется и не хэндлится, но это видимо фича
```
Код для определения начального состояния.  
```
- `ContactSelectorViewModel.phoneEditingChanged(_:)` - логика форматирования может быть энкапсулированна в отдельный сервис чтобы не усложнять вьюмодель
```
\+ 
```
- `comparePhones` и `onlyDigits` могут быть унесены в отдельный static extension дабы не усложнять вьюмодель
```

\+ 

```
Плюс пара минимальных деталей:
- Строки 16, 44, 101 - доступ к синглтону, нет нормального DI = плохо
```

\+ 
```
- 264, `ContactSelectorViewModel.updateHistory`, не механизма обеспечивающего секвентальность выполнения хэндлеров
```

\+ 
```
- 364, weak outlet, незачем
```
Я бы сказал сочетание weak и force unwrap странное и опасное 
```
- `PhoneSelectorTableView.height(for:)`, хардкод высоты, так бывает в 80% случаев по наивности, в 20% потому что фича
```
Тут фиксированная высота для определенных ячеек, само по себе решение с UITableView тоже далеко не из лучших.  

```
- 536, нет необходимости создавать стоковый объект UITableViewCell
```

\+ 